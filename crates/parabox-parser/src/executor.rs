use crate::command::{Assertion, Command, MetaPosition, MetaProtoType, Operation};
use crate::error::{ParseError, ParseResult, Span};
use crate::meta::{MetaKey, MetaName, MetaTable};
use crate::parser::{parse, SpannedCommand};
use crate::source::Source;
use ecow::EcoString;
use parabox::{BlockKey, Direction, MoveError, World};
use parabox_macros::trace_func;
use std::collections::VecDeque;
use std::rc::Rc;
use tracing::{debug, instrument};

/// An executor that runs the parsed commands.
///
/// The executor contains a world and a meta table. The meta table builds up a
/// correspondence between the block names define in the executed script and the
/// block keys generated by the world.
///
/// See [top level documentation](crate) for more information.
pub struct Executor {
    world: World,
    meta: MetaTable,
    commands: VecDeque<SpannedCommand>,
}

impl Executor {
    /// Creates a new executor with an empty world.
    ///
    /// If you want to use an existing world, use [`Executor::from_world`].
    pub fn new() -> Self {
        Self {
            world: World::new(),
            meta: MetaTable::new(),
            commands: VecDeque::new(),
        }
    }

    /// Creates a new executor with the given world.
    ///
    /// Make sure that each block in the world is defined in the meta table. See
    /// [MetaTable] for more information.
    pub fn from_world(world: World, meta: MetaTable) -> Self {
        Self {
            world,
            meta,
            commands: VecDeque::new(),
        }
    }

    /// Returns the world of the executor.
    pub fn world(&self) -> &World {
        &self.world
    }

    /// Returns the meta table of the executor.
    pub fn meta(&self) -> &MetaTable {
        &self.meta
    }

    /// Takes the world and the meta table from the executor.
    pub fn take(self) -> (World, MetaTable) {
        (self.world, self.meta)
    }
}

impl Executor {
    fn contains_meta(&self, block: &EcoString) -> bool {
        self.meta.contains_name(block)
    }

    fn insert_meta(&mut self, block: EcoString, key: BlockKey) {
        debug!("meta: {:?} => #{}", key, block);
        self.meta.insert(block, key);
    }

    fn key_to_name<T: MetaKey>(&self, from: &T) -> Result<T::Target, String> {
        from.convert(&self.meta)
            .map_err(|key| format!("unresolved reference to {:?}", key))
    }

    fn name_to_key<T: MetaName>(&self, from: &T) -> Result<T::Target, String> {
        from.convert(&self.meta)
            .map_err(|block| format!("unresolved reference to {}", block))
    }
}

impl Executor {
    /// Pushes a source of commands to the executor.
    pub fn push_source(&mut self, source: Rc<dyn Source>) -> ParseResult<()> {
        parse(source).map(|commands| {
            self.commands.extend(commands.into_iter());
        })
    }

    /// Returns whether there are more commands to execute.
    pub fn has_next(&self) -> bool {
        !self.commands.is_empty()
    }

    /// Returns the next command to execute, if any.
    pub fn peek(&self) -> Option<&SpannedCommand> {
        self.commands.front()
    }

    /// Executes the next command. Returns the span of the executed command.
    pub fn step(&mut self) -> ParseResult<Span> {
        if let Some(command) = self.commands.pop_front() {
            self.execute(command.command().clone())
                .map(|_| command.span().clone())
                .map_err(|message| ParseError::new(command.span().clone(), message.into()))
        } else {
            panic!("no more commands");
        }
    }

    /// Runs all the commands until there are no more.
    pub fn run_all(&mut self) -> ParseResult<()> {
        while self.has_next() {
            self.step()?;
        }

        Ok(())
    }
}

impl Executor {
    fn execute(&mut self, command: Command) -> Result<(), String> {
        let block = command.block;
        match command.operation {
            Operation::Define(proto) => self.define(block, proto),
            Operation::Place(position) => self.place(block, position),
            Operation::Push(direction, assertion) => self.push(block, direction, assertion),
            Operation::Expect(position) => self.expect(block, position),
        }
    }

    fn define(&mut self, block: EcoString, proto: MetaProtoType) -> Result<(), String> {
        if self.contains_meta(&block) {
            return Err(format!("redefinition of #{}", block));
        }

        let key = self.world.insert(self.name_to_key(&proto)?);
        self.insert_meta(block, key);

        Ok(())
    }

    fn place(&mut self, block: EcoString, position: MetaPosition) -> Result<(), String> {
        self.world
            .place(self.name_to_key(&block)?, self.name_to_key(&position)?);

        Ok(())
    }

    #[trace_func]
    #[instrument(skip(self))]
    fn push(
        &mut self,
        block: EcoString,
        direction: Direction,
        assertion: Assertion,
    ) -> Result<(), String> {
        let result = match self.world.push(self.name_to_key(&block)?, direction) {
            Ok(result) => result,
            Err(error) => {
                match error {
                    MoveError::Orphan(key) => {
                        self.solve_orphan(self.key_to_name(&key)?)?;
                    }
                    MoveError::NoInfinity(key) => {
                        self.solve_no_infinity(self.key_to_name(&key)?)?;
                    }
                    MoveError::NoEpsilon(key) => {
                        self.solve_no_epsilon(self.key_to_name(&key)?)?;
                    }
                }

                return self.push(block, direction, assertion);
            }
        };

        match assertion {
            Assertion::None => {}
            Assertion::Moved => {
                if !result {
                    return Err("the world is not moved".to_string());
                }
            }
            Assertion::Static => {
                if result {
                    return Err("the world is moved".to_string());
                }
            }
        }

        Ok(())
    }

    fn expect(&mut self, block: EcoString, position: MetaPosition) -> Result<(), String> {
        if self.world[self.name_to_key(&block)?].state.position != self.name_to_key(&position)? {
            return Err(format!("expected #{} to be {}", block, position));
        }

        Ok(())
    }
}

impl Executor {
    fn solve_orphan(&mut self, orphan: EcoString) -> Result<(), String> {
        let container: EcoString = format!("{}::container", orphan).into();
        self.define(container.clone(), MetaProtoType::Void { size: (5, 5) })?;
        self.place(orphan.clone(), MetaPosition::inside(container, (2, 2)))?;
        Ok(())
    }

    fn solve_no_infinity(&mut self, block: EcoString) -> Result<(), String> {
        let infinity: EcoString = format!("{}::infinity", block).into();
        self.define(
            infinity.clone(),
            MetaProtoType::Infinity { reference: block },
        )?;
        self.solve_orphan(infinity)?;
        Ok(())
    }

    fn solve_no_epsilon(&mut self, block: EcoString) -> Result<(), String> {
        let epsilon: EcoString = format!("{}::epsilon", block).into();
        self.define(
            epsilon.clone(),
            MetaProtoType::Epsilon {
                reference: block,
                size: (5, 5),
            },
        )?;
        Ok(())
    }
}

impl Executor {
    /// Formats the positions of the blocks in the world.
    ///
    /// This is useful for debugging purposes.
    pub fn format_positions(&self) -> String {
        let blocks = self
            .meta
            .names()
            .into_iter()
            .filter(|block| !block.ends_with("::interior"));
        let indent = blocks.clone().map(|block| block.len()).max().unwrap_or(0);
        let mut result = String::new();

        for block in blocks {
            if block.ends_with("::interior") {
                continue;
            }

            let key = self.meta.get_key(&block).unwrap();
            let position = self.world[key].state.position;
            result.push_str(&format!(
                "{:indent$} -> {}\n",
                block,
                self.key_to_name(&position).unwrap(),
                indent = indent
            ));
        }

        result
    }
}
